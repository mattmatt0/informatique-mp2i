\newcommand\PATH{Lancez `make adapt avant de compiler!`}

\RequirePackage{fix-cm}
\documentclass{scrartcl}

\input{\PATH/../include/preamble.tex}
\input{\PATH/../include/it-tools.tex}
\input{\PATH/../include/math-tools.tex}
\usepackage{lmodern}

\title{Structures de données arborescentes}
\author{}
\date{}

\begin{document}
	\maketitle
	\section{Motivations}
		\subsection{Un arbre pour un objet}
			Pour des éléments d'un ensemble construit par induction, 
			il est approprié d'utiliser une représentation par arbre puisque 
			ces objets ont intrinsèquement une structure arborescente

			\exemple Les expressions booléennes, arithmétiques, de type. 

		\subsection{Un arbre pour une collection d'objet}
			On cherche à stocker une collection d'objets sans multiplicité,
			et dont l'ordre relatif n'est pas significatif 
			(comme dans le cas d'un ensemble).

			On suppose que tous les éléments sont du type \texttt{elem}, 
			et qu'ils sont identifiés de manière unique par une clé, 
			c'est à dire une sous-partie permettant l'identification.
			
			On a alors les méthodes suivantes:
			\begin{multicols}{2}
			\begin{itemize}
				\item \texttt{creer\_ens\_vide : () -> ens}
				\item \texttt{est\_ens\_vide : ens -> bool}
				\item \texttt{appartient : ens$\times$elem -> bool}
				\item \texttt{ajoute\_elem : ens$\times$elem -> ens}
				\item \texttt{supprime\_elem : ens$\times$clé -> ens}
				\item \texttt{trouve\_elem : ens$\times$clé -> elem}
			\end{itemize}
			\end{multicols} 

			\rem On peut aussi imaginer des fonctions \texttt{ajoute\_elem} et \texttt{supprime\_elem}
			qui modifieraient directement l'ensemble donné en entrée, 
			plutôt que de renvoyer un nouvel ensemble. 

		\subsection{Implémentations}
			On peut stocker les éléments dans une liste. 
			On peut aussi associer chaque élément à une clé
			(pour un ensemble de caractères par exemple, leurs valeurs ascii),
			qui permet de les comparer rapidement. 
			Si l'on peut ordonner ces clés, 
			on peut alors classer les éléments par ordre croissant dans un tableau.

			\begin{center}
			\begin{tabular}{| c | c  | c |}
				\hline
				Opération & Complexité (Liste) & Complexité (Tableau ordonné) \\
				\hline
				\texttt{appartient} & $\theta(n)$ & $\theta(\log(n))$ (dichotomie) \\
				\hline
				\texttt{ajoute\_elem} & $\theta(1)$ & $\theta(n)$ \\
				\hline
				\texttt{supprime\_elem} & $\theta(n)$ & $\theta(n)$ \\
				\hline
				\texttt{trouve\_elem} & $\theta(n)$ & $\theta(\log(n))$ \\
				\hline
			\end{tabular}
			\end{center}

			\rem On voit selon le contexte qu'une certaine implémentation sera plus efficace qu'une autre:
			si on doit faire beaucoup d'insertions sans trop chercher d'éléments, le plus efficace sera la liste.
			Par contre, si on n'insère que rarement des éléments mais que 
			l'on est souvent ammené à chercher dans les éléments, le tableau trié sera à préférer.

			ll existe cela dit une structure qui permet d'avoir une complexité d'ajout / suppression et de recherche
			en $\theta(\log(n))$, sous certaines conditions: il s'agit des \textbf{arbres binaires de recherche (ABR)}.

	\section{Arbre binaires}
		\subsection{Ensemble $\mathscr{A}_B$}
			Soit $\mathcal{S}$ un ensemble.
			On définit l'ensemble des arbres binaires étiquetés par $\mathcal{S}$ 
			comme l'ensemble construit par induction à partir de ces deux règles:

			\begin{multicols}{2}
			\begin{itemize}
				\item $V\Big|_{\set{-}}^0$ 
				\item $N\Big|_{\mathcal{S}}^2$ 
			\end{itemize}
			\end{multicols}

			\exemple Soit $\mathcal{S} = \set{1,2,3,4}$. 

			\begin{center}
			\begin{tabular}{c | c | c}
				\begin{tikzpicture}
					\node (a) {$\times$};
				\end{tikzpicture}
				\quad & \quad
				\begin{tikzpicture}
					\node [circle,draw](a) {1}
						child {node (b) {$\times$}}
						child {node (b) {$\times$}};
				\end{tikzpicture} 
				\quad & \quad
				\begin{tikzpicture}[
					level 1/.style={sibling distance=10em}, 
					level 2/.style={sibling distance=5em}, 
					level 3/.style={sibling distance=2em}]
					\node [circle,draw](a) {4}
						child {node [circle,draw] (b) {2}
							child {node (c) {$\times$}}
							child {node (c) {$\times$}}}
						child {node [circle,draw] (b) {3}
							child {node [circle,draw] (c) {$1$}
								child {node (d) {$\times$}}
								child {node (d) {$\times$}}}
							child {node (c) {$\times$}}};
				\end{tikzpicture} \\
				$(V,\_)$ & $(N,1,(V,\_),(V,\_))$  & 
				$(N,4,(N,2,(V,\_),(V,\_)),(N,3,(N,1,(V,\_),(V,\_)),(V,\_)))$
			\end{tabular}
			\end{center}
			
		\subsection{Feuilles}
			\begin{center}\textsl{On fixe désormais $\mathcal{S}$ un ensemble d'étiquettes.
			On notera par ailleurs $N(x,g,d) = (N,x,g,d)$ et $V = (V,\_)$ pour alléger l'écriture.}\end{center}
			
			On dit qu'un arbre $t \in \abins$ est réduit à une feuille ssi il existe $x \in \mathcal{S}$
			tel que $t = N(x,V,V)$.

			\prop{Pour la relation d'ordre $\leq$ associée à la définition inductive de $\abins$, on a:}
			\begin{enumerate}
				\item \textsl{$V$ est le seul élément minimal de $(\abins, \leq)$.}
				\item \textsl{$t$ élément minimal de $\abins\setminus\set{V} \Leftrightarrow$ $t$ est réduit à une feuille.}
			\end{enumerate}
			\begin{demo}
				\item Le 1) découle du fait que $V$ soit le seul cas de base des règles d'induction de $\abins$.
				\item Soit $t$ minimal dans $\abins\setminus\set{V}$. 
				Il existe par définition $x \in \mathcal{S}$ et $(g,d) \in \abins^2$ tels que $t = N(x,g,d)$.
				Comme $g \leq t$ et $d \leq t$, et d'autre part $g \neq t$ et $d \neq t$,
				on en déduit que $g < t$ et $d < t$. 
				Par minimalité de $t$ dans $\abins\setminus\set{V}$, on en déduit que $g = d =V$,
				donc que $t$ est réduit à une feuille.
			\end{demo}

		\subsection{Chemins}
			Considérons l'alphabet $\Sigma = \set{0,1}$. 
			On définit par induction sur $\abins$ l'ensemble des chemins admissibles d'un arbre binaire $t$,
			noté $\text{ch}(t)$, par:
			\[
				\forall t \in \abins: \quad \text{ch}(t) = 
				\begin{cases}
					\varnothing \text{ si } t = V \\ 
					\set{\varepsilon}\cup\set{0.\text{ch}(g)}\cup\set{1.\text{ch}(d)} \text{ si } t = N(x,g,d)
				\end{cases}
			\]

			Soit $t \in \abins$. Un \textbf{noeud} $\mathcal{N}$ de $t$ est un élément de $\text{ch}(t)$. 
			Sa profondeur, notée |$\mathcal{N}$| est alors sa longueur en tant que mot de $\Sigma^*$.
			La taille de $t$, notée $s(t)$, est alors le nombre de noeuds de $t$, 
			autrement dit $\card\text{ch}(t)$.

			\rem Un chemin admissible décrit la "position" d'un "noeud" dans l'arbre.

			\exo Donner une définition inductive de $s(t)$.

			On appelle \textbf{étiquetage} d'un arbre non vide la fonction qui à un noeud de l'arbre associe son étiquette.
			
			Formellement, l'étiquetage est défini inductivement comme suit 
			(on note $\mathcal{E}$ l'ensemble des étiquetages des arbres, c'est à dire des fonctions d'une partie de $\Sigma^*$ dans $\mathcal{S}$):
			\[
				\text{etiq}
				\left(\text{\begin{tabular}{r c l}
					$\mathscr{A}_B(\mathcal{S})\setminus\set{V}$ & $\rightarrow$ & $\mathcal{E}$ \\\vspace{5pt}
					$N(x,V,V)$ & $\mapsto$ & 
						$\left(\text{\begin{tabular}{r c l} 
							$\text{ch}(x,V,V) = \set{\varepsilon}$ & $\to$ & $\mathcal{S}$ \\
							$\varepsilon$ & $\mapsto$ & $x$
						\end{tabular}}\right)$ \\\vspace{5pt}
					$N(x,g,V)$ & $\mapsto$ &
						$\left(\text{\begin{tabular}{r c l}
							$\text{ch}(N,x,g,V)$ & $\to$ & $\mathcal{S}$ \\
							$\varepsilon$ & $\mapsto$ & $x$ \\
							$0 \cdot u$ & $\mapsto$ & $\text{etiq}(g) (u)$
						\end{tabular}}\right)$ \\\vspace{5pt}
					$N(x,V,d)$ & $\mapsto$ &
						$\left(\text{\begin{tabular}{r c l}
							$\text{ch}(N,x,V,d)$ & $\to$ & $\mathcal{S}$ \\
							$\varepsilon$ & $\mapsto$ & $x$ \\
							$1 \cdot u$ & $\mapsto$ & $\text{etiq}(d) (u)$
						\end{tabular}}\right)$ \\\vspace{5pt}
					$N(x,g,d)$ & $\mapsto$ &
						$\left(\text{\begin{tabular}{r c l}
							$\text{ch}(N,x,g,d)$ & $\to$ & $\mathcal{S}$ \\
							$\varepsilon$ & $\mapsto$ & $x$ \\
							$0 \cdot u$ & $\mapsto$ & $\text{etiq}(g) (u)$ \\
							$1 \cdot u$ & $\mapsto$ & $\text{etiq}(d) (u)$ 
						\end{tabular}}\right)$
				\end{tabular}}\right)
			\]

			Soit $t \in \mathscr{A}_B(\mathcal{S})$, $\text{etiq}(t)$ est l'étiquetage de $t$.
			Si $n \in \text{ch}(t)$, alors l'étiquette de $n$ dans $t$ est $\left(\text{etiq}(t)\right)(n)$

		
		\subsection{Vocabulaire}
			Soit $t \in \mathscr{A}_B(\mathcal{S})$.
			Soit $n \in \text{ch}(t)$.
			\begin{itemize}
				\item $n$ est une \textbf{feuille} de $t$ si et seulement si pour tout $u \in \Sigma^*$, $n\cdot u \in \text{ch}(t) \Rightarrow u=\varepsilon$
				\item $n$ est \textbf{racine} de $t$ si et seulement si $n = \varepsilon$
				\item $n$ est un \textbf{noeud interne} de $t$ si et seulement si $n$ n'est pas une feuille.
			\end{itemize}
			
			
			Soient $n$ et $m$ deux chemins admissibles pour $t$ un arbre binaire non vide.
			$m$ est le \textbf{fils gauche} (resp. \textbf{fils droit}) de $n$ si et seulement si $m = n\cdot 0$ (resp. $m = n \cdot 1$).
			Dans les deux cas, $n$ est alors le \textbf{père} de $m$.

			On dit que $m$ est un \textbf{descendant} de $n$ si et seulement si il existe $u \in \Sigma^*$ tel que $m = n \cdot u$.
			Dans ce cas $n$ est un \textbf{ascendant} de $m$.

			\rem Les feuilles sont les noeuds sans enfant, et la racine est le seul noeud sans père.

			Soit $(n_i)_{i \in \intset{0,k}} \in \text{ch}(t)^{k+1}$.
			On dit que $(n_i)$ est une branche de $t$ si et seulement si $n_0 = \varepsilon$ et $n_i$ est le père de $n_{i+1}$ pour tout $i \in \intsete{0,k}$.
			
			Soient $t$ et $t'$ deux arbres binaires sur $\mathcal{S}$. On dit que $t'$ est le \textbf{sous-arbre droit} (resp \textbf{sous-arbre gauche}) de $t$
			si et seulement si il existe $g \in \mathscr{A}_B(\mathcal{S})$ (resp. $d \in \mathscr{A}_B(\mathcal{S})$) tel que $t = N(x,g,t')$ (resp. $t = N(x,t',d)$).
			On dit que $t'$ est un \textbf{sous-arbre} de $t$ si et seulement si $t' \leq t$.

			\rem Notons qu'un arbre binaire peut-être sous-arbre d'un autre tout en étant ni un sous-arbre droit, ni un sous-arbre gauche.

		\subsection{Hauteur}
			On définit par induction la hauteur $h(t)$ d'un arbre binaire $t \in \mathscr{A}_B(\mathcal{S})$ comme valant 
			-1 si $t = V$ et $1 + \max(h(g),h(d))$ si $t = N(x,g,d)$.

			\prop{Soit $t \in \mathscr{A}_B(\mathcal{S}) \setminus \set{V}$. 
				Alors $h(t) = \max_{n \in \text{ch}(t)} \mathrm{prof}(n)$.
				$h(t)+1$ est alors la longueur maximale d'une branche.}
			\begin{demo}
				\item Montrons-le par induction sur $t$ : c'est bien le cas pour $t = N(x,V,V)$
					car $h(t) = 0$, 
					le seul chemin admissible pour cet arbre est $\varepsilon$ qui est de longueur 0,
					et la seule branche de $t$ est alors $(\varepsilon)$, qui est de taille 1.

				\item Soit $t = N(x,g,d) \in \mathscr{A}_B(\mathcal{S})$ avec $g$ et $d$ deux arbres binaires non vides vérifiant la propriété.
					On a 
					\[
						\max_{n \in \text{ch}(t)} \mathrm{prof}(n) = \max(\max_{0\cdot n \in \text{ch}(t)} \mathrm{prof}(n), \max_{1\cdot n \in \text{ch}(t)} \mathrm{prof}(n), 0)
					\]
					en séparant les chemins admissibles de $t$ selon leur première lettre.
					Par définition des chemins admissibles et de la profondeur, on a alors 
					\[
						\max_{n \in \text{ch}(t)} \mathrm{prof}(n) = \max(1 + \max_{n \in \text{ch}(g)} \mathrm{prof}(n), 1 + \max_{n \in \text{ch}(d)} \mathrm{prof}(n) , 1)
					\]
					soit, par hypothèse sur $g$ et $d$, 
					\[
						\max_{n \in \text{ch(t)}} \mathrm{prof}(n) = 1 + \max(h(g), h(d), 0) = 1 + \max(h(g), h(d)) = h(t)
					\] 
					car $g$ et $d$ ne sont pas vides et ont donc une hauteur plus grande que 0.
					On établit le résultat sur la longueur maximale des branches de la même manière.
				
				\item Les cas $t = N(x,g,V)$ et $t = N(x,V,d)$ se traitent de la même manière (la séparation des maximums donne alors un maximum d'un ensemble vide, soit $- \infty$, qui est neutre pour le maximum, ce qui traduit l'inexistance de branches / noeuds à droite ou à gauche de la racine).
			\end{demo}

			\prop{Pour $t \in \mathscr{A}_B(\mathcal{S})$, on a $h(t) + 1 \leq s(t) \leq 2^{h(t)+1}-1$.}
			\begin{demo}
				\item Montrons-le par induction sur $t$ : pour $t = V$, on a $h(t) + 1= 0$, $s(t) = 0$ et $2^{h(t)+1}-1 = 0$.
				\item Soit $t = N(x,g,d) \in \mathscr{A}_B(\mathcal{S})$, où $g$ et $d$ respectent la propriété énoncée.
					Alors 
					\[
						h(t) + 1 = 2 + \max(h(d), h(g)) \leq 2 + h(d) + h(g) 
					\]
					\[
						1 + (h(g)+1) + (h(d)+1) = 3 + h(g) + h(d) \leq 1 + s(g) + s(d)
					\]
					\[
						s(g) + s(d) + 1 \leq 2^{h(t) + 1} - 1 + 2^{h(d) + 1} \leq 2^{\max(h(t),h(d)) + 1} - 1 = 2^{h(t)+1}-1
					\]
					En combinant ces inégalités, il vient le résultat attendu.
			\end{demo}

		\subsection{Parcours}
			Soit $t \in \mathscr{A}_B(\mathcal{S})\setminus\set{V}$.
			$(a_i)_{i\in\intset{1,s(t)}}$ est un \textbf{parcours} de $t$ si et seulement si il existe $\varphi \in \mathcal{F}(\mathrm{ch}(t), \intset{1,s(t)})$ bijective telle que $\forall n \in \mathrm{ch}(t), a_{\varphi(n)} = \text{etiq}(t)(n)$.

			Pour $n \in \mathrm{ch}(t)$ on note 
			\begin{itemize}
				\item $\mathscr{G}(n) = \set{n\cdot 0 \cdot u \tq u \in \Sigma^*} \cap \mathrm{ch}(t)$ l'ensemble des descendants gauches de $n$ ;
				\item $\mathscr{D}(n) = \set{n\cdot 1 \cdot u \tq u \in \Sigma^*} \cap \mathrm{ch}(t)$ l'ensemble des descendants droits de $n$.
			\end{itemize}

			
			Un parcours $(\mathrm{etiq}(t)(\varphi^{-1}(i))_{i \in \intset{1,s(t)}}$ (où $\varphi$ est une bijection de $\mathrm{ch}(t)$ dans $\intset{1, s(t)}$)
			est dit \textbf{préfixe} (resp. \textbf{postfixe}, \textbf{infixe}) si et seulement si pour tout $n \in \mathrm{ch}(t)$, pour tout $g \in \mathscr{G}(n)$ et $d \in \mathscr{D}(n)$,
			on a $\varphi(n) \leq \varphi(g) \leq \varphi(d)$ (resp. $\varphi(g) \leq \varphi(d) \leq \varphi(n)$, $\varphi(g) \leq \varphi(n) \leq \varphi(d)$).

			\exemple Pour l'arbre suivant (les noeuds vides n'ont pas été représentés): 
			\begin{center}
				\begin{tikzpicture}
					\coordinate (n2) at (-90-60:2);
					\coordinate (n36) at (-90+60:2);
					\coordinate (n4) at ($(n2) + (-90-40:2)$);
					\coordinate (n12) at ($(n2) + (-90+40:2)$);
					\coordinate (n18) at ($(n12) + (-90+20:2)$);
					\coordinate (n42) at ($(n36) + (-90+40:2)$);

					\draw (0,0) circle(.5) node {1};
					\draw (n2) circle(.5) node {2};
					\draw (n36) circle(.5) node {36};
					\draw (n4) circle(.5) node {4};
					\draw (n12) circle(.5) node {12};
					\draw (n18) circle(.5) node {18};
					\draw (n42) circle(.5) node {42};

					\draw (-90-60:0.5) -- (-90-60:1.5);
					\draw (-90+60:0.5) -- (-90+60:1.5);
					\draw ($(n2)+(-90-40:0.5)$) -- ($(n2)+(-90-40:1.5)$);
					\draw ($(n2)+(-90+40:0.5)$) -- ($(n2)+(-90+40:1.5)$);
					\draw ($(n36)+(-90+40:0.5)$) -- ($(n36)+(-90+40:1.5)$);
					\draw ($(n12)+(-90+20:0.5)$) -- ($(n12)+(-90+20:1.5)$);
				\end{tikzpicture}
			\end{center}
			\begin{itemize}
				\item Un parcours préfixe est 1; 2; 4; 12; 18; 36; 42;
				\item Un parcours postfixe est 4; 18; 12; 2; 42; 36; 1;
				\item Un parcours infixe est 4; 2; 12; 18; 1; 36; 42.
			\end{itemize}

			\prop{Il y a unicité des parcours préfixes, infixes et postfixes.}
			\begin{demo}
				\item En exercice.
			\end{demo}
			
			On définit aussi le \textbf{parcours en largeur}, pour lequel $\left(\mathrm{prof}\left(\varphi^{-1}(i)\right)\right)_{i \in \intset{1,s(t)}}$ doit être croissante,
			et de parcours en profondeur (hors programme dans le cadre des arbres, mais cela suit le même principe que les parcours en profondeur dans les graphes).

	\section{Arbres binaires de recherches (ABR)}
		\notecentrale{Dans cette partie, $E$ désigne un ensemble muni d'une relation d'ordre totale, notée $\preceq$.}

		Soit $t \in \mathscr{A}_B(E) \setminus \set{V}.$ On pose $e = \mathrm{etiq}(t)$.
		$t$ est un arbre binaire de recherche (abgrégé ABR) si et seulement si pour tout $n \in \mathrm{ch}(t), \max\limits_{g \in \mathscr{G}(n)} e(g) \leq e(n) < \min\limits_{d \in \mathscr{D}(n)} e(n)$. Par convention, l'arbre vide est un arbre de recherche.

		\subsection{Recherche d'éléments}
			Profitons de la structure ordonnée de l'ABR. On procède par dichotomie pour la recherche d'un élément (d'une étiquette).
			
			\begin{algorithm}[H]
				\caption{Recherche d'élément dans un ABR}
				\Entree
				{
					$t \in \mathscr{A}_B(E)$ un ABR à étiquettes dans $E$,
					$e \in E$ l'élément à rechercher dans $t$.
				}
				\Sortie
				{
					Vrai s'il existe un noeud dans $t$ ayant pour étiquette $e$, faux sinon.
				}
				\eSi{$t = V$}
				{
					Renvoyer faux
				}
				{
					Poser $t = N(x,g,d)$ \;
					\eSi{$e = x$}
					{
						Renvoyer vrai
					}
					{
						\eSi{$e < x$}
						{
							Rechercher $e$ dans $g$
						}
						{
							Rechercher $e$ dans $d$
						}
					}
				}
			\end{algorithm}
			($\mathbb{B}$ désigne l'ensemble des booléens : vrai ou faux)

			\prop{Pour tout noeud $n$ d'un arbre binaire de recherche $t \in \mathscr{A}_B(E)$, s'il n'existe pas d'autre noeud dans $t$ ayant la même étiquette que $n$,
				alors le nombre de comparaisons (entre éléments de $E$) effectuées lors de la recherche de $\mathrm{etiq}(t)(n)$ dans $t$ vaut $2\mathrm{prof}(n)+1$.}
			\begin{demo}
				\item Montrons-le par récurrence sur la profondeur du noeud $n$ : le prédicat à prouver est, pour $k \in \mathbb{N}$
				\begin{center}
					$\mathcal{P}(k)$ : pour tout noeud de taille $k$ d'un arbre $t \in \mathsrc{A}_B(E)$, s'il n'existe pas d'autre noeud dans $t$ de même étiquette que $n$,
					alors le nombre de comparaison lors de la recherche de $x = \mathrm{etiq}(t)(n)$ dans $t$ vaut $2k+1$.
				\end{center}
				\item Pour $k=0$, on a nécessairement $n = \varepsilon$, ce qui implique que l'arbre sur lequel on appelle la fonction n'est pas vide,
					et que sa racine est étiquetée par $x$ : ainsi, on effectue une seule comparaison
			\end{demo}

			\corro{Pour tout $e \in E$, la recherche de $e$ dans $t$ engendrera au plus $2h(t)+2$ comparaisons.}
			\begin{demo}
				\item Todo
			\end{demo}

		\subsection{Ajout en feuille}
		\subsection{Suppression}
		\subsection{Limitation de la hauteur}

	\section{Arbres 2-3-4}
		\subsection{Définitions}
		\subsection{Scission d'un 4-noeud}
		\subsection{Insertion dans un arbre 2-3-4}
		\subsection{Suppression dans un arbre 2-3-4}
	\section{Arbres rouge-noir}
	\section{Hachage}
	\section{Implémentation des tas}
		\subsection{Introdution}
		\subsection{Opérations en pseudo-code}

\end{document}
	
